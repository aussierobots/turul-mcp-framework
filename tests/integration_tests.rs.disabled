//! # MCP Framework Integration Tests
//!
//! Comprehensive integration tests to verify MCP 2025-06-18 specification compliance
//! and framework functionality.

#![allow(unused_imports)]
#![allow(dead_code)]

use std::collections::HashMap;
use std::time::Duration;

use turul_mcp_derive::McpTool;
use turul_mcp_server::{McpTool, SessionContext, McpServer};
use turul_mcp_protocol::{ToolSchema, ToolResult, schema::JsonSchema, Meta, ProgressToken, ResultWithMeta, CallToolResult, RequestParams, McpError};
use turul_mcp_protocol::tools::{HasBaseMetadata, HasDescription, HasInputSchema, HasOutputSchema, HasAnnotations, HasToolMeta, ToolAnnotations};
use turul_mcp_json_rpc_server::{JsonRpcRequest, JsonRpcNotification, RequestParams as JsonRpcRequestParams, RequestId, JsonRpcVersion, ResponseResult};
use turul_mcp_protocol::{JsonRpcResponse, JsonRpcError}; // For error handling
use serde_json::{json, Value};
use async_trait::async_trait;

/// Test tool for integration testing
#[derive(McpTool, Clone)]
#[tool(name = "test_add", description = "Add two numbers")]
struct AddTool {
    #[param(description = "First number")]
    a: f64,
    #[param(description = "Second number")]
    b: f64,
}

impl AddTool {
    async fn execute(&self, _session: Option<turul_mcp_server::SessionContext>) -> turul_mcp_server::McpResult<String> {
        tracing::debug!("AddTool executing with values a={}, b={}", self.a, self.b);
        Ok(format!("{} + {} = {}", self.a, self.b, self.a + self.b))
    }
}

// TODO: Re-enable when McpResource derive macro is fully implemented
/*
/// Test resource for integration testing
#[derive(McpResource)]
#[uri = "test://data"]
#[name = "Test Data"]
#[description = "Test data resource"]
struct TestResource {
    #[content]
    #[content_type = "application/json"]
    data: String,
}

impl TestResource {
    fn new() -> Self {
        Self {
            data: json!({
                "test": true,
                "message": "Integration test data"
            }).to_string(),
        }
    }
}
*/

/// Session-aware tool for testing session management
struct SessionTool {
    input_schema: ToolSchema,
}

impl SessionTool {
    fn new() -> Self {
        let input_schema = ToolSchema::object()
            .with_properties(HashMap::from([
                ("message".to_string(), JsonSchema::string().with_description("Test message")),
            ]))
            .with_required(vec!["message".to_string()]);
        Self { input_schema }
    }
}

// Implement fine-grained traits for ToolDefinition
impl HasBaseMetadata for SessionTool {
    fn name(&self) -> &str {
        "session_test"
    }
}

impl HasDescription for SessionTool {
    fn description(&self) -> Option<&str> {
        Some("Test session functionality")
    }
}

impl HasInputSchema for SessionTool {
    fn input_schema(&self) -> &ToolSchema {
        &self.input_schema
    }
}

impl HasOutputSchema for SessionTool {
    fn output_schema(&self) -> Option<&ToolSchema> {
        None
    }
}

impl HasAnnotations for SessionTool {
    fn annotations(&self) -> Option<&ToolAnnotations> {
        None
    }
}

impl HasToolMeta for SessionTool {}

#[async_trait]
impl McpTool for SessionTool {
    
    async fn call(&self, args: Value, session: Option<SessionContext>) -> turul_mcp_server::McpResult<CallToolResult> {
        let message = args["message"].as_str().unwrap_or("default");
        tracing::debug!("SessionTool called with message: {}", message);
        
        let mut response = HashMap::new();
        response.insert("received_message".to_string(), json!(message));
        
        if let Some(session) = session {
            response.insert("has_session".to_string(), json!(true));
            response.insert("session_id".to_string(), json!(session.session_id.to_string()));
            
            // Test session state
            let counter: u64 = (session.get_state)("counter")
                .and_then(|v| v.as_u64())
                .unwrap_or(0);
            (session.set_state)("counter", json!(counter + 1));
            response.insert("call_count".to_string(), json!(counter + 1));
        } else {
            response.insert("has_session".to_string(), json!(false));
        }
        
        let result_json = serde_json::to_value(response).map_err(|e| e.to_string())?;
        Ok(CallToolResult::new(vec![ToolResult::text(result_json.to_string())]))
    }
}

#[tokio::test]
async fn test_derive_macro_tool() {
    let tool = AddTool { a: 5.0, b: 3.0 };
    
    // Test basic properties
    assert_eq!(tool.name(), "test_add");
    assert_eq!(tool.description(), Some("Add two numbers"));
    
    // Test schema generation
    let schema = tool.input_schema();
    println!("Tool schema: {:?}", schema);
    
    // Test execution
    let args = json!({ "a": 10.0, "b": 5.0 });
    let result = tool.call(args, None).await;
    
    assert!(result.is_ok());
    let results = result.unwrap();
    assert_eq!(results.content.len(), 1);
    
    // The exact format may vary, but should contain the calculation
    let result_text = match &results.content[0] {
        ToolResult::Text { text } => text,
        _ => panic!("Expected text result"),
    };
    assert!(result_text.contains("10"));
    assert!(result_text.contains("5"));
    assert!(result_text.contains("15"));
}

// TODO: Re-enable when McpResource derive macro is fully implemented
/*
#[tokio::test]
async fn test_derive_macro_resource() {
    let resource = TestResource::new();
    
    // Test basic properties
    assert_eq!(resource.uri(), "test://data");
    assert_eq!(resource.name(), "Test Data");
    assert_eq!(resource.description(), "Test data resource");
    
    // Test content reading
    let content = resource.read().await;
    assert!(content.is_ok());
    
    let contents = content.unwrap();
    assert_eq!(contents.len(), 1);
    
    // Verify content structure
    match &contents[0] {
        mcp_protocol::resources::ResourceContent::Blob { data, mime_type } => {
            assert_eq!(mime_type, "application/json");
            let parsed: Value = serde_json::from_str(&data).expect("Valid JSON");
            assert_eq!(parsed["test"], true);
            assert_eq!(parsed["message"], "Integration test data");
        }
        _ => panic!("Expected blob content"),
    }
}
*/

// Note: Resource declarative macro and schema_for macro tests are disabled
// until the implementation is completed

#[tokio::test]
async fn test_session_management_basic() {
    let tool = SessionTool::new();
    
    // Test without session
    let args = json!({ "message": "test call" });
    let result = tool.call(args, None).await;
    assert!(result.is_ok());
    
    let results = result.unwrap();
    let result_text = match &results.content[0] {
        ToolResult::Text { text } => text,
        _ => panic!("Expected text result"),
    };
    
    let result_json: Value = serde_json::from_str(&result_text).expect("Valid JSON");
    assert_eq!(result_json["has_session"], false);
    assert_eq!(result_json["received_message"], "test call");
}

#[tokio::test]
async fn test_json_rpc_compliance() {
    // Test request creation with _meta
    let mut other = HashMap::new();
    other.insert("name".to_string(), json!("test_add"));
    other.insert("arguments".to_string(), json!({"a": 1.0, "b": 2.0}));
    
    let params = RequestParams {
        meta: Some(Meta {
            progress_token: Some(ProgressToken::new("test-123")),
            cursor: None,
            total: Some(100),
            has_more: Some(false),
            ..Default::default()
        }),
        other,
    };
    
    let request = JsonRpcRequest::new(RequestId::String("req-001".to_string()), "tools/call".to_string(), Some(params));
    
    // Test serialization
    let json_str = serde_json::to_string(&request).expect("Serialization should work");
    assert!(json_str.contains("progressToken"));
    assert!(json_str.contains("test-123"));
    assert!(json_str.contains("tools/call"));
    
    // Test deserialization
    let parsed: JsonRpcRequest = serde_json::from_str(&json_str).expect("Deserialization should work");
    assert_eq!(parsed.method, "tools/call");
    assert!(parsed.params.is_some());
    
    let parsed_params = parsed.params.unwrap();
    // Note: This JSON-RPC RequestParams structure doesn't have meta field like protocol version
    // Skipping meta field validation for this implementation
    assert_eq!(
        parsed_params.get("progressToken").unwrap().as_str().unwrap(),
        "test-123"
    );
    
    // Test response with _meta
    let mut response_data = HashMap::new();
    response_data.insert("content".to_string(), json!([{"type": "text", "text": "result"}]));
    
    let mut meta_data = HashMap::new();
    meta_data.insert("completed".to_string(), json!(true));
    
    let result = ResultWithMeta::new(response_data).with_meta(meta_data);
    let response = JsonRpcResponse::success(json!("req-001"), result);
    
    // Test trait compliance  
    let response_result = response.result.as_ref().unwrap();
    assert!(!response_result.data.is_empty());
    assert!(response_result.meta.is_some());
    
    // Test serialization includes _meta
    let response_json = serde_json::to_string(&response).expect("Response serialization");
    assert!(response_json.contains("_meta"));
    assert!(response_json.contains("completed"));
}

#[tokio::test]
async fn test_server_builder() {
    let tool = AddTool { a: 0.0, b: 0.0 };
    // let resource = TestResource::new(); // TODO: Re-enable when resource derive works
    
    // Test server building with basic features
    let server_result = McpServer::builder()
        .name("integration-test")
        .version("1.0.0") 
        .title("Integration Test Server")
        .instructions("Test server for integration testing")
        .tool(tool)
        // .resource(resource) // TODO: Re-enable when resource derive works
        // .with_resources() // TODO: Re-enable when resource derive works
        .with_completion()
        .with_logging()
        .with_notifications()
        .bind_address("127.0.0.1:0".parse().unwrap()) // Use port 0 for testing
        .build();
    
    assert!(server_result.is_ok());
    let _server = server_result.unwrap();
    
    // Note: We don't actually run the server in tests as that would require
    // more complex async test setup and port management
}

#[tokio::test]
async fn test_progress_tracking() {
    // Test progress token and meta field handling
    let meta = Meta {
        progress_token: Some(ProgressToken::new("progress-123")),
        current_step: Some(5),
        total_steps: Some(10),
        progress: Some(0.5),
        estimated_remaining_seconds: Some(30.0),
        ..Default::default()
    };
    
    // Test serialization preserves all fields
    let json_str = serde_json::to_string(&meta).expect("Meta serialization");
    assert!(json_str.contains("progressToken"));
    assert!(json_str.contains("progress-123"));
    assert!(json_str.contains("currentStep"));
    assert!(json_str.contains("totalSteps"));
    assert!(json_str.contains("estimatedRemainingSeconds"));
    
    // Test deserialization
    let parsed: Meta = serde_json::from_str(&json_str).expect("Meta deserialization");
    assert_eq!(parsed.progress_token.unwrap().as_str(), "progress-123");
    assert_eq!(parsed.current_step.unwrap(), 5);
    assert_eq!(parsed.total_steps.unwrap(), 10);
    assert_eq!(parsed.progress.unwrap(), 0.5);
    assert_eq!(parsed.estimated_remaining_seconds.unwrap(), 30.0);
}

/// Performance test for macro-generated tools
#[tokio::test]
async fn test_macro_performance() {
    let tool = AddTool { a: 1.0, b: 2.0 };
    
    let start = std::time::Instant::now();
    
    // Execute many tool calls to test performance
    for i in 0..1000 {
        let args = json!({ "a": i as f64, "b": (i + 1) as f64 });
        let result = tool.call(args, None).await;
        assert!(result.is_ok());
    }
    
    let duration = start.elapsed();
    println!("1000 tool calls took: {:?}", duration);
    
    // Should complete within reasonable time (adjust threshold as needed)
    assert!(duration < Duration::from_secs(1));
}

#[tokio::test]
async fn test_error_handling() {
    let tool = AddTool { a: 0.0, b: 0.0 };
    
    // Test with invalid arguments
    let invalid_args = json!({ "a": "not_a_number", "b": 2.0 });
    let result = tool.call(invalid_args, None).await;
    
    // Should handle the error gracefully
    assert!(result.is_err());
    let error_msg = result.unwrap_err();
    assert!(error_msg.to_string().contains("Invalid parameter type"));
}

#[tokio::test]
async fn test_specification_compliance() {
    // Test that our JSON-RPC messages match MCP 2025-06-18 specification
    
    // 1. Test request structure
    let request = JsonRpcRequest::new(json!("test-id"), "initialize".to_string());
    let request_json = serde_json::to_string(&request).unwrap();
    let request_value: Value = serde_json::from_str(&request_json).unwrap();
    
    assert_eq!(request_value["jsonrpc"], "2.0");
    assert_eq!(request_value["id"], "test-id");
    assert_eq!(request_value["method"], "initialize");
    
    // 2. Test response structure with _meta
    let mut data = HashMap::new();
    data.insert("protocolVersion".to_string(), json!("2025-06-18"));
    
    let mut meta = HashMap::new();
    meta.insert("serverVersion".to_string(), json!("1.0.0"));
    
    let result = ResultWithMeta::new(data).with_meta(meta);
    let response = JsonRpcResponse::success(json!("test-id"), result);
    let response_json = serde_json::to_string(&response).unwrap();
    let response_value: Value = serde_json::from_str(&response_json).unwrap();
    
    assert_eq!(response_value["jsonrpc"], "2.0");
    assert_eq!(response_value["id"], "test-id");
    assert!(response_value["result"].is_object());
    assert!(response_value["result"]["_meta"].is_object());
    
    // 3. Test _meta field structure
    assert_eq!(
        response_value["result"]["_meta"]["serverVersion"],
        "1.0.0"
    );
}

/// MCP 2025-06-18 Specification Compliance Tests
#[cfg(test)]
mod mcp_compliance_tests {
    use super::*;

    #[tokio::test]
    async fn test_json_rpc_request_structure() {
        // Valid JSON-RPC 2.0 request structure
        let valid_request = json!({
            "jsonrpc": "2.0",
            "method": "initialize",
            "params": {
                "protocolVersion": "2025-06-18",
                "capabilities": {},
                "clientInfo": {
                    "name": "test-client",
                    "version": "1.0.0"
                }
            },
            "id": 1
        });

        // Parse as MCP request
        let request: JsonRpcRequest = serde_json::from_value(valid_request).unwrap();
        
        // Validate required fields
        assert_eq!(request.jsonrpc, "2.0");
        assert_eq!(request.method, "initialize");
        assert!(request.params.is_some());
        assert_eq!(request.id, json!(1));
    }

    #[tokio::test]
    async fn test_json_rpc_response_structure() {
        // Test successful response
        let mut data = HashMap::new();
        data.insert("protocolVersion".to_string(), json!("2025-06-18"));
        data.insert("capabilities".to_string(), json!({}));
        data.insert("serverInfo".to_string(), json!({
            "name": "test-server",
            "version": "1.0.0"
        }));
        
        let result = ResultWithMeta::new(data);
        let success_response = JsonRpcResponse::success(json!(1), result);

        assert_eq!(success_response.jsonrpc, "2.0");
        assert_eq!(success_response.id, json!(1));
        assert!(success_response.result.is_some());
        assert!(success_response.error.is_none());
    }

    #[tokio::test]
    async fn test_tool_call_message_structure() {
        // MCP 2025-06-18 tool call structure with _meta
        let tool_call = json!({
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "calculator",
                "arguments": {
                    "operation": "add",
                    "a": 5,
                    "b": 3
                },
                "_meta": {
                    "progressToken": "calc-123"
                }
            },
            "id": "call-1"
        });

        let request: JsonRpcRequest = serde_json::from_value(tool_call).unwrap();
        assert_eq!(request.method, "tools/call");
        
        let params = request.params.unwrap();
        assert_eq!(params.get("name"), Some(&json!("calculator")));
        assert!(params.get("arguments").unwrap().is_object());
        assert!(params.meta.is_some());
        assert_eq!(params.meta.unwrap().progress_token.unwrap().as_str(), "calc-123");
    }

    #[tokio::test]
    async fn test_meta_field_compliance() {
        // Test _meta field with progressToken and custom fields
        let request_with_meta = json!({
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "test_tool",
                "arguments": {},
                "_meta": {
                    "progressToken": "progress-abc-123",
                    "sessionId": "session-xyz-789",
                    "customField": "custom_value"
                }
            },
            "id": 1
        });

        let request: JsonRpcRequest = serde_json::from_value(request_with_meta).unwrap();
        let params = request.params.unwrap();
        
        // _meta should be preserved
        assert!(params.meta.is_some());
        let meta = params.meta.unwrap();
        assert_eq!(meta.progress_token.unwrap().as_str(), "progress-abc-123");
        // Note: sessionId and customField are not part of the standard Meta struct
        // They would be in the other HashMap if needed
    }

    #[tokio::test]
    async fn test_notification_structure() {
        // Test various MCP notifications
        let notifications = vec![
            ("notifications/initialized", json!({})),
            ("notifications/progress", json!({
                "progressToken": "token-123",
                "progress": 50,
                "total": 100
            })),
            ("notifications/resources/listChanged", json!({})),
            ("notifications/tools/listChanged", json!({})),
            ("notifications/message", json!({
                "level": "info",
                "logger": "mcp.server",
                "data": "Test message"
            }))
        ];

        for (method, params) in notifications {
            let notification = if params == json!({}) {
                JsonRpcNotification::new(method.to_string())
            } else {
                let request_params = RequestParams {
                    meta: None,
                    other: serde_json::from_value(params).unwrap()
                };
                JsonRpcNotification::new(method.to_string())
                    .with_params(request_params)
            };
            
            let serialized = serde_json::to_value(&notification).unwrap();
            assert_eq!(serialized["jsonrpc"], "2.0");
            assert_eq!(serialized["method"], method);
            assert!(serialized.get("id").is_none()); // Notifications must not have id
        }
    }

    #[tokio::test]
    async fn test_error_response_compliance() {
        // Test standard JSON-RPC error codes
        let errors = vec![
            (-32700, "Parse error"),
            (-32600, "Invalid Request"),
            (-32601, "Method not found"),
            (-32602, "Invalid params"),
            (-32603, "Internal error"),
        ];

        for (code, message) in errors {
            let error = JsonRpcError {
                code,
                message: message.to_string(),
                data: None,
            };
            
            let response = JsonRpcResponse::error(json!(1), error);
            
            assert_eq!(response.jsonrpc, "2.0");
            assert_eq!(response.id, json!(1));
            assert!(response.result.is_null());
            assert!(response.error.is_some());
            
            let error = response.error.unwrap();
            assert_eq!(error.code, code);
            assert_eq!(error.message, message);
        }
    }

    #[tokio::test]
    async fn test_content_type_structures() {
        // Test various content types in MCP 2025-06-18
        let content_types = vec![
            json!({
                "type": "text",
                "text": "This is plain text content"
            }),
            json!({
                "type": "image",
                "data": "base64-encoded-image-data",
                "mimeType": "image/png"
            }),
            json!({
                "type": "resource",
                "resource": {
                    "uri": "file:///example.txt",
                    "text": "File contents here"
                }
            })
        ];

        for content in content_types {
            assert!(content["type"].is_string());
            assert!(!content["type"].as_str().unwrap().is_empty());
            
            match content["type"].as_str().unwrap() {
                "text" => assert!(content["text"].is_string()),
                "image" => {
                    assert!(content["data"].is_string());
                    assert!(content["mimeType"].is_string());
                },
                "resource" => {
                    assert!(content["resource"].is_object());
                    assert!(content["resource"]["uri"].is_string());
                },
                _ => panic!("Unknown content type"),
            }
        }
    }

    #[tokio::test]
    async fn test_cursor_pagination() {
        // Test cursor-based pagination structure
        let paginated_response = json!({
            "jsonrpc": "2.0",
            "result": {
                "resources": [
                    {
                        "uri": "file:///first.txt",
                        "name": "First File"
                    },
                    {
                        "uri": "file:///second.txt", 
                        "name": "Second File"
                    }
                ],
                "nextCursor": "page-2-token-abc123"
            },
            "id": 1
        });

        let response: JsonRpcResponse = serde_json::from_value(paginated_response).unwrap();
        let result = response.result.as_value().unwrap();
        
        assert!(result.data["resources"].is_array());
        assert_eq!(result.data["nextCursor"], "page-2-token-abc123");
        
        // Test that resources have required fields
        let resources = result.data["resources"].as_array().unwrap();
        for resource in resources {
            assert!(resource["uri"].is_string());
            assert!(resource["name"].is_string());
        }
    }

    #[tokio::test]
    async fn test_protocol_version_compliance() {
        // Test that our implementation supports MCP 2025-06-18
        let supported_version = "2025-06-18";
        
        let initialize_request = json!({
            "jsonrpc": "2.0",
            "method": "initialize",
            "params": {
                "protocolVersion": supported_version,
                "capabilities": {},
                "clientInfo": {
                    "name": "compliance-test",
                    "version": "1.0.0"
                }
            },
            "id": 1
        });

        let request: JsonRpcRequest = serde_json::from_value(initialize_request).unwrap();
        let params = request.params.unwrap();
        
        assert_eq!(params.get("protocolVersion"), Some(&json!(supported_version)));
        assert!(params.get("capabilities").unwrap().is_object());
        assert!(params.get("clientInfo").unwrap().is_object());
        assert_eq!(params.get("clientInfo").unwrap().get("name"), Some(&json!("compliance-test")));
    }

    #[tokio::test]
    async fn test_framework_integration_compliance() {
        // Test that our framework produces compliant messages
        let other = HashMap::new();
        let params = RequestParams {
            meta: Some(Meta {
                progress_token: Some(ProgressToken::new("list-tools-123")),
                ..Default::default()
            }),
            other,
        };
        
        let request = JsonRpcRequest {
            version: JsonRpcVersion::V2_0,
            method: "tools/list".to_string(),
            params: Some(params),
            id: RequestId::String("test-list".to_string()),
        };

        // Serialize and deserialize to ensure round-trip compatibility
        let serialized = serde_json::to_string(&request).unwrap();
        let deserialized: JsonRpcRequest = serde_json::from_str(&serialized).unwrap();
        
        assert_eq!(deserialized.version, JsonRpcVersion::V2_0);
        assert_eq!(deserialized.method, "tools/list");
        assert_eq!(deserialized.id, RequestId::String("test-list".to_string()));
        
        let params = deserialized.params.unwrap();
        // Note: JsonRpcRequestParams doesn't have meta field, it's part of the enum structure
        // Need to check if this is the right approach for this test
    }
}

// ===========================================
// === Four-Level Calculator Tool Tests ===
// ===========================================

/// Integration tests for the four-level calculator tool pattern.
/// This test suite verifies that all four levels of tool creation work correctly:
/// - Level 1: Function macros (ultra-simple)
/// - Level 2: Derive macros (struct-based)
/// - Level 3: Builder pattern (runtime flexibility)  
/// - Level 4: Manual implementation (maximum control)
#[cfg(test)]
mod calculator_levels_tests {
    use super::*;

    // ===========================================
    // === Level 1: Function Macro ===
    // ===========================================

    use turul_mcp_derive::mcp_tool;

    #[mcp_tool(name = "calculator_add_function_test", description = "Add two numbers using function macro")]
    async fn calculator_add_function_test(
        #[param(description = "First number")] a: f64,
        #[param(description = "Second number")] b: f64,
    ) -> turul_mcp_server::McpResult<f64> {
        Ok(a + b)
    }

    #[tokio::test]
    async fn test_level1_function_macro() {
        let tool = calculator_add_function_test();
        let args = json!({"a": 5.0, "b": 3.0});
        
        let result = tool.call(args, None).await.unwrap();
        
        // Verify structured content (Level 1 should wrap in {"result": value})
        assert!(result.structured_content.is_some());
        if let Some(structured) = result.structured_content {
            let result_value = structured.get("result").unwrap().as_f64().unwrap();
            assert_eq!(result_value, 8.0);
        }
        
        // Verify basic content
        assert!(!result.content.is_empty());
        assert_eq!(result.is_error, Some(false));
    }

    // ===========================================
    // === Level 3: Builder Pattern ===
    // ===========================================

    use turul_mcp_server::ToolBuilder;

    #[tokio::test]
    async fn test_level3_builder_pattern() {
        let tool = ToolBuilder::new("calculator_add_builder_test")
            .description("Add two numbers using builder pattern")
            .number_param("a", "First number")
            .number_param("b", "Second number")
            .number_output()
            .execute(|args| async move {
                let a = args.get("a").and_then(|v| v.as_f64())
                    .ok_or("Missing parameter 'a'")?;
                let b = args.get("b").and_then(|v| v.as_f64())
                    .ok_or("Missing parameter 'b'")?;
                
                let sum = a + b;
                Ok(json!({"result": sum}))
            })
            .build()
            .unwrap();
        
        let args = json!({"a": 4.0, "b": 6.0});
        let result = tool.call(args, None).await.unwrap();
        
        // Verify structured content (builder should provide schema)
        assert!(result.structured_content.is_some());
        if let Some(structured) = result.structured_content {
            let result_value = structured.get("result").unwrap().as_f64().unwrap();
            assert_eq!(result_value, 10.0);
        }
        
        assert!(!result.content.is_empty());
        assert_eq!(result.is_error, Some(false));
    }

    // ===========================================
    // === Level 4: Manual Implementation ===
    // ===========================================

    use turul_mcp_protocol::tools::{
        ToolResult, CallToolResult, ToolSchema,
        HasBaseMetadata, HasDescription, HasInputSchema, HasOutputSchema, 
        HasAnnotations, HasToolMeta
    };
    use turul_mcp_protocol::schema::JsonSchema;

    #[derive(Clone)]
    struct CalculatorAddManualTool;

    impl HasBaseMetadata for CalculatorAddManualTool {
        fn name(&self) -> &str { "calculator_add_manual_test" }
        fn title(&self) -> Option<&str> { Some("Manual Test Calculator") }
    }

    impl HasDescription for CalculatorAddManualTool {
        fn description(&self) -> Option<&str> { 
            Some("Add two numbers using manual implementation")
        }
    }

    impl HasInputSchema for CalculatorAddManualTool {
        fn input_schema(&self) -> &ToolSchema {
            static INPUT_SCHEMA: std::sync::OnceLock<ToolSchema> = std::sync::OnceLock::new();
            INPUT_SCHEMA.get_or_init(|| {
                ToolSchema::object()
                    .with_properties(HashMap::from([
                        ("a".to_string(), JsonSchema::number()),
                        ("b".to_string(), JsonSchema::number()),
                    ]))
                    .with_required(vec!["a".to_string(), "b".to_string()])
            })
        }
    }

    impl HasOutputSchema for CalculatorAddManualTool {
        fn output_schema(&self) -> Option<&ToolSchema> { None }
    }

    impl HasAnnotations for CalculatorAddManualTool {
        fn annotations(&self) -> Option<&ToolAnnotations> { None }
    }

    impl HasToolMeta for CalculatorAddManualTool {
        fn tool_meta(&self) -> Option<&HashMap<String, Value>> { None }
    }

    #[async_trait]
    impl McpTool for CalculatorAddManualTool {
        async fn call(&self, args: Value, _session: Option<SessionContext>) -> turul_mcp_server::McpResult<CallToolResult> {
            let a = args.get("a").and_then(|v| v.as_f64())
                .ok_or_else(|| McpError::missing_param("a"))?;
            let b = args.get("b").and_then(|v| v.as_f64())
                .ok_or_else(|| McpError::missing_param("b"))?;
            
            let sum = a + b;
            
            Ok(CallToolResult::success(vec![
                ToolResult::text(format!("Sum: {}", sum))
            ]))
        }
    }

    #[tokio::test]
    async fn test_level4_manual_implementation() {
        let tool = CalculatorAddManualTool;
        let args = json!({"a": 9.0, "b": 1.0});
        
        let result = tool.call(args, None).await.unwrap();
        
        // Manual implementation returns simple text, no structured content
        assert!(result.structured_content.is_none());
        assert!(!result.content.is_empty());
        assert_eq!(result.is_error, Some(false));
        
        // Verify the text contains the correct sum
        if let ToolResult::Text { text } = &result.content[0] {
            assert!(text.contains("10"));
        } else {
            panic!("Expected text result");
        }
    }

    // ===========================================
    // === Cross-Level Consistency Tests ===
    // ===========================================

    #[tokio::test]
    async fn test_all_levels_handle_missing_params() {
        let incomplete_args = json!({"a": 5.0}); // Missing 'b' parameter
        
        // Level 1
        let level1_tool = calculator_add_function_test();
        let level1_result = level1_tool.call(incomplete_args.clone(), None).await;
        assert!(level1_result.is_err());
        
        // Level 3 
        let level3_tool = ToolBuilder::new("test")
            .number_param("a", "First number")
            .number_param("b", "Second number")
            .execute(|args| async move {
                let a = args.get("a").and_then(|v| v.as_f64()).ok_or("Missing a")?;
                let b = args.get("b").and_then(|v| v.as_f64()).ok_or("Missing b")?;
                Ok(json!(a + b))
            })
            .build()
            .unwrap();
        
        let level3_result = level3_tool.call(incomplete_args.clone(), None).await;
        assert!(level3_result.is_err());
        
        // Level 4
        let level4_tool = CalculatorAddManualTool;
        let level4_result = level4_tool.call(incomplete_args.clone(), None).await;
        assert!(level4_result.is_err());
    }

    #[tokio::test]
    async fn test_all_levels_produce_consistent_results() {
        let args = json!({"a": 12.5, "b": 7.5});
        let expected_sum = 20.0;
        
        // Level 1: Function macro
        let level1_tool = calculator_add_function_test();
        let level1_result = level1_tool.call(args.clone(), None).await.unwrap();
        
        if let Some(structured) = &level1_result.structured_content {
            let result_value = structured.get("result").unwrap().as_f64().unwrap();
            assert_eq!(result_value, expected_sum);
        }
        
        // Level 3: Builder pattern  
        let level3_tool = ToolBuilder::new("test")
            .number_param("a", "First")
            .number_param("b", "Second")
            .number_output()
            .execute(|args| async move {
                let a = args.get("a").and_then(|v| v.as_f64()).ok_or("Missing a")?;
                let b = args.get("b").and_then(|v| v.as_f64()).ok_or("Missing b")?;
                Ok(json!({"result": a + b}))
            })
            .build()
            .unwrap();
        
        let level3_result = level3_tool.call(args.clone(), None).await.unwrap();
        
        if let Some(structured) = &level3_result.structured_content {
            let result_value = structured.get("result").unwrap().as_f64().unwrap();
            assert_eq!(result_value, expected_sum);
        }
        
        // Level 4: Manual implementation returns text, so we parse it
        let level4_tool = CalculatorAddManualTool;
        let level4_result = level4_tool.call(args.clone(), None).await.unwrap();
        
        if let ToolResult::Text { text } = &level4_result.content[0] {
            // Extract number from "Sum: 20" format
            assert!(text.contains(&expected_sum.to_string()));
        }
    }
}

// ===========================================
// === Custom Output Field Name Tests ===
// ===========================================

#[cfg(test)]
mod custom_output_field_tests {
    use super::*;
    use turul_mcp_derive::mcp_tool;

    #[mcp_tool(name = "test_custom_field", description = "Test custom output field", output_field = "sum")]
    async fn test_custom_field_tool(
        #[param(description = "First number")] a: f64,
        #[param(description = "Second number")] b: f64,
    ) -> turul_mcp_server::McpResult<f64> {
        Ok(a + b)
    }

    #[tokio::test]
    async fn test_custom_output_field_name() {
        let tool = test_custom_field_tool();
        let args = json!({"a": 5.0, "b": 3.0});
        
        let result = tool.call(args, None).await.unwrap();
        
        // Verify structured content uses "sum" instead of "result"
        assert!(result.structured_content.is_some());
        if let Some(structured) = result.structured_content {
            // Should have "sum" field, not "result" field
            assert!(structured.get("sum").is_some());
            assert!(structured.get("result").is_none());
            
            let sum_value = structured.get("sum").unwrap().as_f64().unwrap();
            assert_eq!(sum_value, 8.0);
        }
        
        // Verify basic properties
        assert!(!result.content.is_empty());
        assert_eq!(result.is_error, Some(false));
    }

    #[mcp_tool(name = "test_default_field", description = "Test default output field")]
    async fn test_default_field_tool(
        #[param(description = "First number")] a: f64,
        #[param(description = "Second number")] b: f64,
    ) -> turul_mcp_server::McpResult<f64> {
        Ok(a + b)
    }

    #[tokio::test]
    async fn test_default_output_field_name() {
        let tool = test_default_field_tool();
        let args = json!({"a": 7.0, "b": 2.0});
        
        let result = tool.call(args, None).await.unwrap();
        
        // Verify structured content uses default "result" field
        assert!(result.structured_content.is_some());
        if let Some(structured) = result.structured_content {
            // Should have "result" field by default
            assert!(structured.get("result").is_some());
            assert!(structured.get("sum").is_none());
            
            let result_value = structured.get("result").unwrap().as_f64().unwrap();
            assert_eq!(result_value, 9.0);
        }
    }
}

