//! End-to-End SSE Message Flow Tests
//!
//! These tests verify that SSE notifications actually work end-to-end:
//! - Real notifications are sent and received
//! - Correct correlation IDs are maintained
//! - Session isolation is properly enforced
//! - Messages flow through the StreamManager correctly
//!
//! This addresses the critical gap where previous tests only checked connection
//! establishment but not actual message delivery.
//!
//! ## Current Status: API Migration Required
//!
//! This test file needs updating to work with the current API:
//! 1. JsonRpcHandler trait signature changed - params are now LegacyRequestParams
//! 2. SessionContext no longer has session_id() method - it's a field
//! 3. JsonRpcDispatcher API changed - no longer has register_handler()
//! 4. McpError variants changed - MethodNotFound doesn't exist
//! 5. HttpMcpServer API changed - register_handler expects different types
//! 6. Error handling needs anyhow conversion fixes
//!
//! The SSE functionality is tested by the working SSE tests in prompts/resources packages.
//! This comprehensive E2E test should be updated in a future iteration.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;

use anyhow::Result;
use serde_json::{json, Value};
use tokio::time::sleep;
use tracing::{info, warn};
use uuid::Uuid;

use turul_http_mcp_server::{HttpMcpServer, StreamManager};
use turul_mcp_json_rpc_server::{JsonRpcDispatcher, JsonRpcHandler};
use turul_mcp_protocol::McpError;
use turul_mcp_session_storage::{InMemorySessionStorage, SseEvent};

/// Test handler that can trigger notifications for testing
#[derive(Clone)]
struct NotificationTestHandler {
    stream_manager: Arc<StreamManager>,
}

impl NotificationTestHandler {
    fn new(stream_manager: Arc<StreamManager>) -> Self {
        Self {
            stream_manager,
        }
    }

    /// Trigger a test notification for a specific session
    async fn trigger_notification(&self, session_id: &str, message: &str) -> Result<(), McpError> {
        let data = json!({
            "message": message,
            "session_id": session_id,
            "timestamp": chrono::Utc::now().timestamp_millis(),
            "test_id": Uuid::now_v7().to_string()
        });

        self.stream_manager
            .broadcast_to_session(session_id, "test_notification".to_string(), data)
            .await
            .map_err(|e| McpError::transport(&format!("Notification delivery failed: {}", e)))?;

        Ok(())
    }
}

#[async_trait::async_trait]
impl JsonRpcHandler for NotificationTestHandler {
    type Error = McpError;

    async fn handle(
        &self,
        method: &str,
        params: Option<Value>,
        session: Option<turul_mcp_json_rpc_server::r#async::SessionContext>,
    ) -> Result<Value, Self::Error> {
        match method {
            "test/trigger_notification" => {
                let session_id = session
                    .as_ref()
                    .and_then(|s| s.session_id())
                    .ok_or_else(|| McpError::InvalidParameters("Missing session ID".to_string()))?;

                let message = params
                    .and_then(|p| p.get("message"))
                    .and_then(|m| m.as_str())
                    .unwrap_or("Test notification");

                self.trigger_notification(session_id, message).await?;

                Ok(json!({
                    "status": "notification_sent",
                    "session_id": session_id,
                    "message": message
                }))
            }
            _ => Err(McpError::MethodNotFound(method.to_string())),
        }
    }
}

/// Test client that can receive and parse SSE events
#[derive(Clone)]
struct SseTestClient {
    client: reqwest::Client,
    base_url: String,
    session_id: Option<String>,
}

impl SseTestClient {
    fn new(port: u16) -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: format!("http://127.0.0.1:{}/mcp", port),
            session_id: None,
        }
    }

    /// Initialize MCP session
    async fn initialize(&mut self) -> Result<()> {
        let request = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": "2025-06-18",
                "capabilities": {
                    "logging": {}
                },
                "clientInfo": {
                    "name": "sse-e2e-test",
                    "version": "1.0.0"
                }
            }
        });

        let response = self
            .client
            .post(&self.base_url)
            .header("Content-Type", "application/json")
            .json(&request)
            .send()
            .await?;

        // Extract session ID from headers
        if let Some(session_header) = response.headers().get("mcp-session-id") {
            self.session_id = Some(session_header.to_str()?.to_string());
            info!("Initialized session: {:?}", self.session_id);
        }

        let _result: HashMap<String, Value> = response.json().await?;
        Ok(())
    }

    /// Trigger a test notification
    async fn trigger_notification(&self, message: &str) -> Result<Value> {
        let request = json!({
            "jsonrpc": "2.0",
            "id": 2,
            "method": "test/trigger_notification",
            "params": {
                "message": message
            }
        });

        let mut req_builder = self
            .client
            .post(&self.base_url)
            .header("Content-Type", "application/json")
            .json(&request);

        if let Some(ref session_id) = self.session_id {
            req_builder = req_builder.header("mcp-session-id", session_id);
        }

        let response = req_builder.send().await?;
        let result: HashMap<String, Value> = response.json().await?;

        if let Some(result_value) = result.get("result") {
            Ok(result_value.clone())
        } else {
            Err(format!("No result in response: {:?}", result).into())
        }
    }

    /// Connect to SSE stream and collect events for a specified duration
    async fn collect_sse_events(&self, duration: Duration) -> Result<Vec<SseEvent>> {
        let mut req_builder = self
            .client
            .get(&self.base_url)
            .header("Accept", "text/event-stream");

        if let Some(ref session_id) = self.session_id {
            req_builder = req_builder.header("mcp-session-id", session_id);
        }

        let mut response = req_builder.send().await?;
        let mut events = Vec::new();

        let start = std::time::Instant::now();
        while start.elapsed() < duration {
            if let Some(chunk) = response.chunk().await? {
                if let Ok(text) = String::from_utf8(chunk.to_vec()) {
                    // Parse SSE format
                    for line in text.lines() {
                        if line.starts_with("data: ") {
                            let data = &line[6..]; // Remove "data: " prefix
                            if let Ok(parsed) = serde_json::from_str::<Value>(data) {
                                // Convert to SseEvent format for easier testing
                                let event = SseEvent {
                                    id: parsed.get("id").and_then(|v| v.as_u64()).unwrap_or(0),
                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,
                                    event_type: parsed.get("type").and_then(|v| v.as_str()).unwrap_or("unknown").to_string(),
                                    data: parsed.clone(),
                                    retry: None,
                                };
                                events.push(event);
                            }
                        }
                    }
                }
            }

            // Small delay to prevent busy waiting
            sleep(Duration::from_millis(50)).await;
        }

        Ok(events)
    }

    fn session_id(&self) -> Option<&String> {
        self.session_id.as_ref()
    }
}

/// Start a test server with notification capabilities
async fn start_test_server() -> Result<(HttpMcpServer, u16)> {
    // Create session storage and stream manager
    let session_storage = Arc::new(InMemorySessionStorage::new());
    let stream_manager = Arc::new(StreamManager::with_config(
        session_storage.clone(),
        turul_http_mcp_server::StreamConfig::default(),
    ));

    // Create notification test handler
    let test_handler = NotificationTestHandler::new(stream_manager.clone());

    // Create dispatcher and register handler
    let mut dispatcher = JsonRpcDispatcher::<McpError>::new();
    dispatcher.register_handler("test/trigger_notification", test_handler);

    // Create server with session handler
    let port = portpicker::pick_unused_port().expect("No available port");
    let server = HttpMcpServer::builder_with_storage(session_storage)
        .bind_address(([127, 0, 0, 1], port).into())
        .mcp_path("/mcp")
        .cors(true)
        .get_sse(true)
        .register_handler(vec!["test/trigger_notification".to_string()], dispatcher)
        .build();

    info!("Test server started on port {}", port);
    Ok((server, port))
}

#[tokio::test]
async fn test_e2e_sse_notification_delivery() -> Result<()> {
    let _ = tracing_subscriber::fmt::try_init();

    info!("ðŸ§ª Starting E2E SSE notification delivery test");

    // Start test server
    let (server, port) = start_test_server().await.expect("Failed to start test server");

    // Start server in background
    let server_handle = tokio::spawn(async move {
        server.run().await
    });

    // Give server time to start
    sleep(Duration::from_millis(500)).await;

    // Create test client
    let mut client = SseTestClient::new(port);
    client.initialize().await.expect("Failed to initialize client");

    let session_id = client.session_id().unwrap().clone();
    info!("âœ… Client initialized with session: {}", session_id);

    // Start SSE connection in background
    let client_clone = client.clone();
    let sse_handle = tokio::spawn(async move {
        client_clone.collect_sse_events(Duration::from_secs(5)).await
    });

    // Give SSE connection time to establish
    sleep(Duration::from_millis(500)).await;

    // Trigger test notification
    let test_message = format!("Test notification for session {}", session_id);
    let trigger_result = client
        .trigger_notification(&test_message)
        .await
        .expect("Failed to trigger notification");

    info!("âœ… Notification triggered: {:?}", trigger_result);

    // Wait for events
    let events = sse_handle.await.expect("SSE collection failed")?;
    info!("ðŸ“¨ Collected {} SSE events", events.len());

    // Verify we received the notification
    let mut found_notification = false;
    for event in &events {
        info!("Event: type={}, data={:?}", event.event_type, event.data);

        if let Some(message) = event.data.get("message").and_then(|m| m.as_str()) {
            if message == test_message {
                found_notification = true;
                info!("âœ… Found matching notification: {}", message);

                // Verify session ID correlation
                if let Some(event_session_id) = event.data.get("session_id").and_then(|s| s.as_str()) {
                    assert_eq!(event_session_id, session_id, "Session ID mismatch in notification");
                    info!("âœ… Session ID correlation verified");
                }
            }
        }
    }

    assert!(found_notification, "Expected notification not found in SSE events");

    // Cleanup
    server_handle.abort();

    info!("ðŸŽ‰ E2E SSE notification delivery test passed!");
    Ok(())
}

#[tokio::test]
async fn test_e2e_sse_session_isolation() -> Result<()> {
    let _ = tracing_subscriber::fmt::try_init();

    info!("ðŸ§ª Starting E2E SSE session isolation test");

    // Start test server
    let (server, port) = start_test_server().await.expect("Failed to start test server");

    // Start server in background
    let server_handle = tokio::spawn(async move {
        server.run().await
    });

    // Give server time to start
    sleep(Duration::from_millis(500)).await;

    // Create two test clients
    let mut client1 = SseTestClient::new(port);
    let mut client2 = SseTestClient::new(port);

    client1.initialize().await.expect("Failed to initialize client1");
    client2.initialize().await.expect("Failed to initialize client2");

    let session1_id = client1.session_id().unwrap().clone();
    let session2_id = client2.session_id().unwrap().clone();

    assert_ne!(session1_id, session2_id, "Sessions should have different IDs");
    info!("âœ… Created two sessions: {} and {}", session1_id, session2_id);

    // Start SSE connections for both clients
    let client1_clone = client1.clone();
    let client2_clone = client2.clone();

    let sse1_handle = tokio::spawn(async move {
        client1_clone.collect_sse_events(Duration::from_secs(6)).await
    });

    let sse2_handle = tokio::spawn(async move {
        client2_clone.collect_sse_events(Duration::from_secs(6)).await
    });

    // Give SSE connections time to establish
    sleep(Duration::from_millis(500)).await;

    // Trigger notification only for client1
    let test_message_1 = format!("Message for session {}", session1_id);
    client1.trigger_notification(&test_message_1).await
        .expect("Failed to trigger notification for client1");

    info!("âœ… Triggered notification for session 1");

    // Small delay
    sleep(Duration::from_millis(200)).await;

    // Trigger notification only for client2
    let test_message_2 = format!("Message for session {}", session2_id);
    client2.trigger_notification(&test_message_2).await
        .expect("Failed to trigger notification for client2");

    info!("âœ… Triggered notification for session 2");

    // Collect events from both clients
    let events1 = sse1_handle.await.expect("SSE collection failed for client1")?;
    let events2 = sse2_handle.await.expect("SSE collection failed for client2")?;

    info!("ðŸ“¨ Client1 collected {} events, Client2 collected {} events",
          events1.len(), events2.len());

    // Verify session isolation
    let mut client1_got_own_message = false;
    let mut client1_got_other_message = false;

    for event in &events1 {
        if let Some(message) = event.data.get("message").and_then(|m| m.as_str()) {
            if message == test_message_1 {
                client1_got_own_message = true;
            } else if message == test_message_2 {
                client1_got_other_message = true;
                warn!("âŒ Client1 received Client2's message - session isolation violated!");
            }
        }
    }

    let mut client2_got_own_message = false;
    let mut client2_got_other_message = false;

    for event in &events2 {
        if let Some(message) = event.data.get("message").and_then(|m| m.as_str()) {
            if message == test_message_2 {
                client2_got_own_message = true;
            } else if message == test_message_1 {
                client2_got_other_message = true;
                warn!("âŒ Client2 received Client1's message - session isolation violated!");
            }
        }
    }

    // Assertions
    assert!(client1_got_own_message, "Client1 should receive its own notification");
    assert!(client2_got_own_message, "Client2 should receive its own notification");
    assert!(!client1_got_other_message, "Client1 should NOT receive Client2's notification");
    assert!(!client2_got_other_message, "Client2 should NOT receive Client1's notification");

    // Cleanup
    server_handle.abort();

    info!("ðŸŽ‰ E2E SSE session isolation test passed!");
    Ok(())
}

#[tokio::test]
async fn test_e2e_sse_correlation_ids() -> Result<()> {
    let _ = tracing_subscriber::fmt::try_init();

    info!("ðŸ§ª Starting E2E SSE correlation ID test");

    // Start test server
    let (server, port) = start_test_server().await.expect("Failed to start test server");

    // Start server in background
    let server_handle = tokio::spawn(async move {
        server.run().await
    });

    // Give server time to start
    sleep(Duration::from_millis(500)).await;

    // Create test client
    let mut client = SseTestClient::new(port);
    client.initialize().await.expect("Failed to initialize client");

    let session_id = client.session_id().unwrap().clone();

    // Start SSE connection
    let client_clone = client.clone();
    let sse_handle = tokio::spawn(async move {
        client_clone.collect_sse_events(Duration::from_secs(4)).await
    });

    // Give SSE connection time to establish
    sleep(Duration::from_millis(500)).await;

    // Trigger multiple notifications with different correlation data
    let test_messages = vec![
        "First test message",
        "Second test message",
        "Third test message",
    ];

    for (i, message) in test_messages.iter().enumerate() {
        client.trigger_notification(message).await
            .expect("Failed to trigger notification");
        info!("âœ… Triggered notification {}: {}", i + 1, message);

        // Small delay between notifications
        sleep(Duration::from_millis(100)).await;
    }

    // Collect events
    let events = sse_handle.await.expect("SSE collection failed")?;
    info!("ðŸ“¨ Collected {} SSE events", events.len());

    // Verify all notifications were received with correct correlation
    let mut found_messages = std::collections::HashSet::new();

    for event in &events {
        if let Some(message) = event.data.get("message").and_then(|m| m.as_str()) {
            if test_messages.contains(&message) {
                found_messages.insert(message);

                // Verify session correlation
                if let Some(event_session_id) = event.data.get("session_id").and_then(|s| s.as_str()) {
                    assert_eq!(event_session_id, session_id, "Session ID correlation failed");
                }

                // Verify test_id is present (unique correlation ID)
                assert!(event.data.get("test_id").is_some(), "Missing test_id correlation field");

                info!("âœ… Verified correlation for message: {}", message);
            }
        }
    }

    // Verify we received all expected messages
    for expected_message in &test_messages {
        assert!(found_messages.contains(expected_message),
                "Missing expected message: {}", expected_message);
    }

    assert_eq!(found_messages.len(), test_messages.len(),
               "Message count mismatch - expected {}, found {}",
               test_messages.len(), found_messages.len());

    // Cleanup
    server_handle.abort();

    info!("ðŸŽ‰ E2E SSE correlation ID test passed!");
    Ok(())
}